# SwiftAutomation README

## About

SwiftAutomation is an Apple event bridge that allows Apple's Swift language 
to control "AppleScriptable" macOS applications directly. For example:

  // tell application "iTunes" to play
  try ITunes().play()

  // tell application "Finder" to set fileNames to name of every file of home
  let fileNames = try Finder().home.files.name.get() as [String]


  // tell application "TextEdit" to make new document ¬
  //                                     with properties {text:"Hello World!"}
  try TextEdit().make(new: TED.document, 
                      withProperties: [TED.text: "Hello World!"])


The SwiftAutomation framework defines the basic functionality for constructing
object specifiers, converting data between Swift and AE types, and sending 
Apple events to running applications. Generated Swift files supply the glue
code for controlling individual applications using human-readable terminology.


## Get it

To clone the Xcode project to your own machine:

  git clone https://bitbucket.org/hhas/swiftae.git

The project includes a `SwiftAutomation.framework` target for embedded use.


## Install it

To embed SwiftAutomation for use in Swift-based GUI apps see Xcode's Workspace
documentation.

To use SwiftAutomation in Swift "scripting", see the Installing SwiftAutomation
chapter of the SwiftAutomation documentation. Until Swift provides a stable ABI
some manual set-up is required.


## Try it

To run simple examples (see test/main.swift), build and run the `test` target.

Additional glues can be generated by building the `aeglue` target and running
the resulting `aeglue` command line tool in Terminal. For example, to generate
a Swift glue and accompanying documentation for macOS's Photos application:

  /path/to/aeglue -o ~/Desktop Photos

Note that `aeglue` normally retrieves application terminology using `ascrgdte`
('get dynamic terminology') Apple events. Some applications (e.g. Finder) have
faulty `ascrgdte` handlers that fail to return correct terminology, in which
case use the `-s` or 'Use SDEF terminology' options instead. (Be aware that
SDEF-based terminology may also contain bugs and omissions, in which case use
raw four-char codes or correct generated glue code by hand.)

SwiftAutomation requires macOS 10.11 and Swift 3.0 and Xcode 8.0 or later.


## Love it

SwiftAutomation's goal is to provide better than 99.9% compatibility across the
wide range of real-world "AppleScriptable" macOS applications available today.

Unlike macOS's ScriptingBridge framework (an ORM-style design that suffers from
many missing/broken features and incompatibilities with many "AppleScriptable"
applications), SwiftAutomation uses the same RPC + Query Builder approach used
by the appscript AE bridges for Python and Ruby, not to mention AppleScript
itself! Appscript has already been tested and proven over a decade of real-world
production use, and SwiftAutomation updates and improves on that original design
while tailoring it to take full advantage of Swift's powerful syntax and static
type systems.

SwiftAutomation is still under development, but even as Apple decide the future
of Automation across its products, we believe SwiftAutomation could mark a new
dawn for both current and future Automation technologies, attracting thousands
of ambitious new Swift users to macOS's Automation platform, establish a roadmap
for upgrading and enhancing the existing platform, and laying the groundwork for
establishing full, modern, advanced Automation capabilities on iOS too.


## Status

SwiftAutomation is currently approaching beta status. The implementation is
largely complete though not yet fully tested, and the documentation is a work
in progress. Expect errors and omissions, use at own risk, etc.


## Known issues

When using SwiftAutomation within an interactive playground, be aware that Xcode
automatically re-runs ALL code within a playground whenever a line of code is
modified, causing ALL application commands to be re-sent. This is not a problem
when using non-mutating application commands such as `get` and `count`; however,
take care when using commands that modify the application's state - `make`,
`move`, `delete`, etc. - within a playground as sending these more than once may
have unintended/undesirable results. This is a playground issue that affects ALL
non-idempotent and/or unsafe function calls, not just application commands.


## Etc.

No warranty given, E&OE, use at own risk, etc.

